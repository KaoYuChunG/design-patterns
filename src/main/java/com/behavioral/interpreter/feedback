基本介绍
1) 在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法 单元再通过语法分析器构建语法分析树，最终形成一颗抽象的语法分析树。这 里的词法分析器和语法分析器都可以看做是解释器
2) 解释器模式（Interpreter Pattern）：是指给定一个语言(表达式)，定义它的文法 的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子(表达式)
3) 应用场景 • 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树 • 一些重复出现的问题可以用一种简单的语言来表达 • 一个简单语法需要解释的场景
4) 这样的例子还有，比如编译器、运算表达式计算、正则表达式、机器人等

原理
1) Context: 是环境角色,含有解释器之外的全局信息.
2) AbstractExpression: 抽象表达式， 声明一个抽象的解释操作,这个方法为抽象语法树中所有的节点(子類)所共享
3) TerminalExpression: 为终结符表达式, 实现与文法中的终结符相关的解释操作
4) NonTermialExpression: 为非终结符表达式，为文法中的非终结符实现解释操作.
5) 说明： 输入Context he TerminalExpression 信息通过Client 输入即可

应用场景
前面介绍了解释器模式的结构与特点，下面分析它的应用场景：
1)当语言的文法较为简单，且执行效率不是关键问题时
2)当问题重复出现，且可以用一种简单的语言来进行表达时
3)当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释
4)注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在Java 中可以用 Expression4J 或 Jep 等来设计。

注意事项和细节
1) 当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可以 考虑使用解释器模式，让程序具有良好的扩展性
2) 应用场景：编译器、运算表达式计算、正则表达式、机器人等
3) 使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用 方法，将会导致调试非常复杂、效率可能降低.